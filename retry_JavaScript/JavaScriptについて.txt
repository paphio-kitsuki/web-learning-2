JavaScriptの歴史
1996年、Netscape社からJavaScriptがリリース
LiveScriptと呼ばれる予定が、当初人気だったJavaにあやかり、ほぼ共通点ないのにJavaScriptに改名...
同年にECMAScriptと呼ばれる、標準化されたJavaScriptが誕生
その後、何度か更新され、今に至る。(ECMAScriptをもとにして、さまざまな会社がJavaScriptを開発している)

JavaScriptの特徴
・入出力の概念がない。
・オブジェクト指向プログラミングも、関数型プログラミングもサポートする

型
・Number...数値型、BigInt...長整数型、String...文字列型、Boolean...論理型、Object...オブジェクト型、Symbol...シンボル型
・関数もオブジェクト。
・Number型は64ビットの浮動小数点数(しかし整数値は32ビットで扱われる)

数値変換
・parseInt() (基数指定可) or parseFloat() (基数指定不可、10固定) で文字列を数値へ変換
・変換する文字列が数値でない場合、NaNが返される。NaNはどう計算してもNaNになる。Number.isNaN()で確認
・Infinityや-Infinityもある。これらはisFinite()で確認

null・undefined
・null...値がないことを示す値
・undefined...初期化されていないことを示す値

boolean
・false, 0, "", NaN, null, undefinedはすべてfalse、その他はすべてtrueとして扱われる。

変数・定数
・letはブロック内で使える変数、constはブロック内で使える定数
・JavaScriptは、昔は関数しかスコープを持たなかった。varを用いて宣言すると、今でも関数内で有効な変数が宣言できる。

等号
・==による比較は、型強制を行って比較する。(1 == true -> true, 1をbooleanに変換するとtrueとなるため)
・===による比較は、型強制を行わずに比較する。(1 === true -> false)

拡張for
・for(let value of array)で、配列のそれぞれの値に対する処理を行える
・for(let property in object)で、オブジェクトのプロパティに対する処理を行える

オブジェクト
・オブジェクト生成時は「var obj = {};」とした方が良い
・function Person(name, age) {}とすることで、name,ageプロパティをもつPersonオブジェクトのプロトタイプを宣言
・プロパティには.と[]の二通りでアクセス可能

配列
・var a = new Array();　または　var a = [];　で配列の定義が可能
・配列のプロパティ「length」は、配列の一番大きな添え字より1大きい値を取る。要素数ではない。
・存在しない配列の添え字はundefinedを返す
・配列のメソッドの説明：https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array

関数
・JavaScriptでは、関数に返り値を明示する必要はない
・返り値のない関数や、returnのみの場合、undefinedが返る
・期待された引数を渡さずに関数を実行することもできる(その場合、undefinedが渡される)
・期待された引数以上の数を渡して実行することもできる(余分な引数は無視される)
・関数内には「arguments」という変数が存在する。これは、すべての引数の値を保持する、配列のようなオブジェクト
・「...変数名」とかくことで、取得されなかった引数(残余引数)のリストを取得できる。for...ofループで処理できる
・無名関数を変数に代入したり、引数に渡したりできる。さらに、(function(){})();とすることで、その場で関数を宣言して実行できる。

クラスっぽいもの
・JavaScriptでは、関数をクラスのように扱うことが出来る
・thisを使うと、その関数を.や[]で呼び出した変数が返る。何もなしに呼ばれた関数の場合、thisにはグローバルオブジェクトが返る。
・newを使うと、からの新しいオブジェクトを作り、それをthisに指定した後、後ろに続く関数が呼ばれる。
・クラス名.prototypeとすることで、全インスタンスで共有されるプロパティを設定できる。(Javaで言うstaticか)
・組み込みオブジェクトのプロトタイプにも付け加えられる

クロージャ
・引数を参照した関数を返す関数など、関数自体が終わっても引数を使う場合がある。
　なぜ使えるかというと、関数内で作成されたローカル変数を保持する「scope」オブジェクトがプロパティにあるから。
　しかし、このscopeはコードからアクセスできない。また、ローカル変数を参照しているものがなくなるまで、ガベージコレクションの対象にもならない。
